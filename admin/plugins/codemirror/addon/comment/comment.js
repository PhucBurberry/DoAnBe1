ath: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\67fb2af3d2219b403e419535a547c019.cab
[0b94:001a][2024-08-13T14:16:10] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\67fb2af3d2219b403e419535a547c019.cab' succeeded. Hash: C0A3064890A0D102E677331693172E17A7BAC2407281D2E5B1FED5DB2D5B5593
[0b94:001a][2024-08-13T14:16:10] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\685f3d4691f444bc382762d603a99afc.cab
[0b94:001a][2024-08-13T14:16:10] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\685f3d4691f444bc382762d603a99afc.cab' succeeded. Hash: 7FB00882CF1976119B0CF9B271F0EBC7A00F8485334C4859DDC6D86FAFF0B907
[0b94:001a][2024-08-13T14:16:10] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\68a5a2b14625f935761325cddfadca11.cab
[0b94:001a][2024-08-13T14:16:10] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\68a5a2b14625f935761325cddfadca11.cab' succeeded. Hash: A8F40A3C7305A02075E8C36B4C57FC7E78C7220F41A8D4EBA7CE88C067556EA0
[0b94:001a][2024-08-13T14:16:10] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\68de71e3e2fb9941ee5b7c77500c0508.cab
[0b94:0019][2024-08-13T14:16:10] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_WindowsPerformanceToolkit.6DCF4F84A9590A0FC355\Installers\WPTx64 (DesktopEditions)-x86_en-us.msi' succeeded. Hash: 702786642ECBA7599E3ACDFD81CAB5D652398253237D0B5C84CDA74AD5626A86
[0b94:0019][2024-08-13T14:16:10] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_WindowsPerformanceToolkit.6DCF4F84A9590A0FC355\Installers\WPTx64 (OnecoreUAP)-x64_en-us.msi
[0b94:0019][2024-08-13T14:16:10] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_WindowsPerformanceToolkit.6DCF4F84A9590A0FC355\Installers\WPTx64 (OnecoreUAP)-x64_en-us.msi' succeeded. Hash: FB1A7A0B3110CFF0C044D09888063E409A2C28B9C7560525C841449F65C29194
[0b94:0019][2024-08-13T14:16:10] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_WindowsPerformanceToolkit.6DCF4F84A9590A0FC355\Installers\WPTx64 (OnecoreUAP)-x86_en-us.msi
[0b94:0019][2024-08-13T14:16:11] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_WindowsPerformanceToolkit.6DCF4F84A9590A0FC355\Installers\WPTx64 (OnecoreUAP)-x86_en-us.msi' succeeded. Hash: F98884F9D4183D2A153BBF644F9699A29E29C04E6436B72960458143E82EB309
[0b94:0019][2024-08-13T14:16:11] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_WindowsPerformanceToolkit.6DCF4F84A9590A0FC355\Installers\WPTx86 (DesktopEditions)-x86_en-us.msi
[0b94:001a][2024-08-13T14:16:12] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\68de71e3e2fb9941ee5b7c77500c0508.cab' succeeded. Hash: 541272C1ACCF29FCD1A99EB0F0C2A4A0A56B4A00AB0CC39AD958AD560926EFC5
[0b94:001a][2024-08-13T14:16:12] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\69661e20556b3ca9456b946c2c881ddd.cab
[0b94:001a][2024-08-13T14:16:13] SHA256 verification for 'C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\69661e20556b3ca9456b946c2c881ddd.cab' succeeded. Hash: 0B0E3E057CB231544897D5543F98BC099541E880AC524C4B7B63C77AC6541117
[0b94:001a][2024-08-13T14:16:13] Checking SHA256 for path: C:\Users\Administrator\AppData\Local\Temp\l3sy1453\Win11SDK_10.0.22621.00C0B50536C9040EC40F\Installers\6b12414fdb1b4978419abcd383206c09.cab
[0b94:001a][/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return

    var end = Math.min(to.line, self.lastLine());
    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;

    var pad = options.padding == null ? " " : options.padding;
    if (from.line > end) return;

    self.operation(function() {
      if (options.fullLines != false) {
        var lastLineHasText = nonWS.test(self.getLine(end));
        self.replaceRange(pad + endString, Pos(end));
        self.replaceRange(startString + pad, Pos(from.line, 0));
        var lead = options.blockCommentLead || mode.blockCommentLead;
        if (lead != null) for (var i = from.line + 1; i <= end; ++i)
          if (i != end || lastLineHasText)
            self.replaceRange(lead + pad, Pos(i, 0));
      } else {
        var atCursor = cmp(self.getCursor("to"), to) == 0, empty = !self.somethingSelected()
        self.replaceRange(endString, to);
        if (atCursor) self.setSelection(empty ? to : self.getCursor("from"), to)
        self.replaceRange(startString, from);
      }
    });
  });

  CodeMirror.defineExtension("uncomment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = getMode(self, from);
    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);

    // Try finding line comments
    var lineString = options.lineComment || mode.lineComment, lines = [];
    var pad = options.padding == null ? " " : options.padding, didSomething;
    lineComment: {
      if (!lineString) break lineComment;
      for (var i = start; i <= end; ++i) {
        var line = self.getLine(i);
        var found = line.indexOf(lineString);
        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
        if (found == -1 && nonWS.test(line)) break lineComment;
        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
        lines.push(line);
      }
      self.operation(function() {
        for (var i = start; i <= end; ++i) {
          var line = lines[i - start];
          var pos = line.indexOf(lineString), endPos = pos + lineString.length;
          if (pos < 0) continue;
          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
          didSomething = true;
          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
        }
      });
      if (didSomething) return true;
    }

    // Try block comments
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) return false;
    var lead = options.blockCommentLead || mode.blockCommentLead;
    var startLine = self.getLine(start), open = startLine.indexOf(startString)
    if (open == -1) return false
    var endLine = end == start ? startLine : self.getLine(end)
    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)
    if (close == -1 ||
        !/comment/.test(self.getTokenTypeAt(insideStart)) ||
        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||
        self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
      return false;

    // Avoid killing block comments completely outside the selection.
    // Positions of the last startString before the start of the selection, and the first endString after it.
    var lastStart = startLine.lastIndexOf(startString, from.ch);
    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;
    // Positions of the first endString after the end of the selection, and the last startString before it.
    firstEnd = endLine.indexOf(endString, to.ch);
    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;
    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;

    self.operation(function() {
      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),
                        Pos(end, close + endString.length));
      var openEnd = open + startString.length;
      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
      if (lead) for (var i = start + 1; i <= end; ++i) {
        var line = self.getLine(i), found = line.indexOf(lead);
        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
        var foundEnd = found + lead.length;
        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
      }
    });
    return true;
  });
});
