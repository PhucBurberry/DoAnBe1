 + " (" + debugId + ")"); this._idToCallback[id] = callback; this._group.register(object, id); } } cleanupSome() { let cleaned = false; if (gc) { gc(); } if (this._group && this._group.cleanupSome) { this._group.cleanupSome(); cleaned = true; } return cleaned; } } class RemoteRefTracker { constructor(releaseObjectsCallback, log) { this._maxRemoteSequenceId = 0; this._mapRemoteIdToRefCount = {}; this._releaseObjectsCallback = releaseObjectsCallback; this._log = log; } addSequenceId(sequenceId) { if (sequenceId > this._maxRemoteSequenceId) { this._maxRemoteSequenceId = sequenceId; } } addReference(remoteId) { if (remoteId === null || remoteId === undefined) { console.assert(false, "invalid remoteId in addReference:" + remoteId); return; } if (this._mapRemoteIdToRefCount.hasOwnProperty(remoteId)) { ++this._mapRemoteIdToRefCount[remoteId]; } else { this._mapRemoteIdToRefCount[remoteId] = 1; } } removeReference(remoteId) { if (remoteId === null || remoteId === undefined) { console.assert(false, "invalid remoteId in removeReference:" + remoteId); return; } console.assert(this._mapRemoteIdToRefCount.hasOwnProperty(remoteId)); const newCount = --this._mapRemoteIdToRefCount[remoteId]; if (newCount === 0) { delete this._mapRemoteIdToRefCount[remoteId]; if (this._releaseObjectsCallback) { this._releaseObjectsCallback( this._maxRemoteSequenceId, JSON.stringify([remoteId])); this._log("Sending remote release message " + remoteId); } } } } class IdGenerator { constructor() { this._nextId = 1; } getNextId() { return this._nextId++; } } class Deferral { constructor() { let controlsRef = this.controls = { clear: function() { controlsRef.resolve = controlsRef.reject = controlsRef.clear = function() {}; controlsRef = null; } }; this.promise = new Promise((resolveIn, rejectIn) => { this.controls.resolve = function deferralResolve(...args) { const result = resolveIn.apply(null, args); controlsRef.clear(); return result; }; this.controls.reject = function deferralReject(...args) { const result = rejectIn.apply(null, args); controlsRef.clear(); return result; }; }); } }; class ObjectSerializer { constructor(idGenerator, groupId, proxyOptions, options) { this._idGenerator = idGenerator; this._groupId = groupId; this._proxyOptions = proxyOptions; this._proxyOptionsSymbol = Symbol("EmbeddedBrowserWebView.proxyOptions"); this._options = options; this._serializationOptionsPropertyName = "1B9FCAB5-FB86-4D78-91DE-7BC2B4077E5B"; this._objectIdToObject = {}; this._paramTracker = {}; } _getProxyOptions(object) { if (object && object.hasOwnProperty(this._proxyOptionsSymbol)) { return object[this._proxyOptionsSymbol]; } return null; } _hasProxyOptions(object) { return this._getProxyOptions(object) !== null; } _setProxyOptions(object, options) { Object.defineProperty(object, this._proxyOptionsSymbol, { value: options, configurable: true }); } _getOrCreateProxyOptions(object) { let options = this._getProxyOptions(object); if (!options) { const remoteObjectId = this._idGenerator.getNextId(); options = { remoteObjectId, groupId: this._groupId, type: "proxy", remoteSequenceId: 0 }; this._setProxyOptions(object, options); this._objectIdToObject[remoteObjectId] = object; } return options; } _updateSequenceNumberForProxyOptions(options, sequenceId) { console.assert(options); if (options.groupId === this._groupId) { console.assert(options.remoteSequenceId <= sequenceId); options.remoteSequenceId = sequenceId; } } getObjectByObjectId(objectId) { return this._objectIdToObject[objectId]; } setObjectProxyOptionsFromResponse(object, response) { this._setProxyOptions( object, response.parameters.result[this._serializationOptionsPropertyName]); } setObjectByWellKnownObjectId(object, objectId) { console.assert(objectId < 1); this._objectIdToObject[objectId] = object; } getObjectIdBySerializedObjectMessage(message) { let remoteObjectId = null; if (message && message.parameters && message.parameters.result && message.parameters.result.hasOwnProperty(this._serializationOptionsPropertyName)) { remoteObjectId = message.parameters .result[this._serializationOptionsPropertyName].remoteObjectId; if (remoteObjectId === undefined) remoteObjectId = null; } return remoteObjectId; } getHostKeyNamesBySerializedObjectMessage(message) { let hostKeyNames = []; if (message && message.parameters && message.parameters.result && message.parameters.result.hasOwnProperty(this._serializationOptionsPropertyName)) { hostKeyNames = message.parameters .result[this._serializationOptionsPropertyName].hostKeyNames || []; } return hostKeyNames; } updateSequenceNumberFromSerializedObjectMessage(message) { if (message && message.parameters && message.parameters.result && message.parameters.result.hasOwnProperty(this._serializationOptionsPropertyName)) { const options = message.parameters.result[this._serializationOptionsPropertyName]; if (options.seq_no) { this._proxyOptions.remoteRefTracker.addSequenceId(options.seq_no); } } } releaseObjects(sequenceId, objectIds) { for (const id of objectIds) { const object = this.getObjectByObjectId(id); if (object) { const options = this._getProxyOptions(object); if (options) { if (options.remoteSequenceId <= sequenceId) { delete object[this._proxyOptionsSymbol]; delete this._objectIdToObject[id]; } } } } } getAndClearIsCacheableBySerializedObjectMessage(message) { let cacheable = false; if (message && message.parameters) { cacheable = message.parameters.cache_able; delete message.parameters.cache_able; if (!cacheable && message.parameters.result && message.parameters.result.hasOwnProperty(this._serializationOptionsPropertyName)) { cacheable = message.parameters .result[this._serializationOptionsPropertyName].cache_able; delete message.parameters .result[this._serializationOptionsPropertyName].cache_able; } } return cacheable; } serialize(object, sequenceId) { try { const thisObjectSerializer = this; return JSON.stringify(object, function(key, value) { let result = value; if (typeof value === "function" || thisObjectSerializer._hasProxyOptions(value)) { let options = thisObjectSerializer._getOrCreateProxyOptions(value); thisObjectSerializer._updateSequenceNumberForProxyOptions(options, sequenceId); result = {}; result[thisObjectSerializer._serializationOptionsPropertyName] = options; if (key === "toString") { try { result.value = value(); } catch (e) {} } } else if (thisObjectSerializer._options.shouldSerializeDates && (this[key] instanceof Date)) { result = { [thisObjectSerializer._serializationOptionsPropertyName]: { type: "date" }, value: this[key].getTime() }; } else if (typeof value === "undefined") { result = null; } return result; }); } catch (e) { throw e; } } deserialize(sync, has_object, debugId, objectSerialized) { let serializationOptions = objectSerialized ? objectSerialized[this._serializationOptionsPropertyName] : null; if (serializationOptions && serializationOptions.type) { if (serializationOptions.type == "date") { if (this._options.shouldSerializeDates) { return new Date(objectSerialized.value.jsTime); } else { return objectSerialized.value.date; } } } if (!has_object) return objectSerialized; return JSON.parse(JSON.stringify(objectSerialized), (key, value) => { let result = value; let options = value && value[this._serializationOptionsPropertyName]; if (options) { if (options.remoteObjectId && options.groupId !== this._groupId) { if (options.seq_no) { this._proxyOptions.remoteRefTracker.addSequenceId(options.seq_no); } let basis = undefined; let hostKeyNames = undefined; let hostPrecacheProperties = undefined; let outArrayResult = undefined; let outArrayIndex = undefined; if (options.scriptBehavior) { switch (options.scriptBehavior) { case 1: basis = {}; Object.getOwnPropertyNames(Array.prototype).concat( Object.getOwnPropertySymbols(Array.prototype)).filter( name => name != 'length').forEach(name => { basis[name] = Array.prototype[name]; }); basis[Symbol.isConcatSpreadable] = true; hostKeyNames = function() { const length = this.getHostProperty("length"); if (this._arrayPropertyNames === undefined) { this._arrayPropertyNames = []; } if (this._arrayPropertyNames.length > length) { this._arrayPropertyNames.length = length; } else if (this._arrayPropertyNames.length < length) { for (let idx = this._arrayPropertyNames.length; idx < length; ++idx) { this._arrayPropertyNames[idx] = idx.toString(10); } } return this._arrayPropertyNames; }; break; case 2: basis = {}; let hostKeyNamesCache = { arr: null }; hostKeyNames = function() { let result = []; if (hostKeyNamesCache.arr != null) { result = hostKeyNamesCache.arr; } else { const getAllKeyNames = this.getHostProperty('getAllKeyNames'); if (getAllKeyNames) { const allKeyNames = getAllKeyNames(); result = allKeyNames.keyNames; if (allKeyNames.cacheable) { hostKeyNamesCache.arr = result; } } else { let first = this.getHostProperty('first'); if (first) { const itr = first.call(this); if (itr.hasCurrent) { do { result.push(itr.current.key); } while (itr.moveNext()); } } else { first = this.getHostProperty('First'); if (first) { const itr = first.call(this); if (itr.HasCurrent) { do { result.push(itr.Current.Key); } while (itr.MoveNext()); } } else { console.error('WebView2 projection map object missing first method.'); } } } } return result; }; break; default: console.error( 'WebView2 projection unknown scriptBehavior ' + options.scriptBehavior); break; } } else if (options.basis) { basis = this.deserialize(sync, has_object, debugId, options.basis); let bindFnNames = []; if (!Array.isArray(basis)) { switch (typeof basis) { case 'string': basis = new String(basis); bindFnNames = ['toString', 'valueOf']; break; case 'boolean': basis = new Boolean(basis); bindFnNames = ['toString', 'valueOf']; break; case 'number': basis = new Number(basis); bindFnNames = ['toExponential', 'toFixed', 'toLocaleString', 'toPrecision', 'toString', 'valueOf']; break; } bindFnNames.forEach(findFnName => basis[findFnName] = basis[findFnName].bind(basis)); basis[Symbol.isConcatSpreadable] = false; } else { const prev = basis; basis = {}; Object.getOwnPropertyNames(prev.constructor.prototype).concat( Object.getOwnPropertySymbols(prev.constructor.prototype)).filter( name => name != 'length').forEach(name => { basis[name] = prev[name]; }); basis[Symbol.isConcatSpreadable] = true; } } if (!hostKeyNames) { if (options.hostKeyNames) { hostKeyNames = this.deserialize(sync, has_object, debugId, options.hostKeyNames); } else { hostKeyNames = []; } } if (!hostPrecacheProperties) { if (options.hostPrecacheProperties) { hostPrecacheProperties = this.deserialize(sync, has_object, debugId, options.hostPrecacheProperties); } else { hostPrecacheProperties = []; } } if (!outArrayResult) { if (options.outArrayResult) { outArrayResult = this.deserialize(sync, has_object, debugId, options.outArrayResult); } } if (!outArrayIndex) { if (options.outArrayIndex) { outArrayIndex = options.outArrayIndex; } } const shouldBeThenable = !!key; result = this.createKnownRemoteProxy( options.remoteObjectId, shouldBeThenable, sync, debugId, basis, hostKeyNames); this._setProxyOptions(result, options); if (hostPrecacheProperties) { for (const [propertyName,value] of Object.entries(hostPrecacheProperties)) { result.setLocalProperty(propertyName, value); } } if (outArrayResult && outArrayIndex) { if (this._proxyOptions.objectSerializer._paramTracker[value.callId] !== undefined) { for (let i = 0; i < outArrayResult.length; i++) { for (let j = 0; j < outArrayResult[i].length; j++) { this._proxyOptions.objectSerializer._paramTracker[value.callId][outArrayIndex[i]][j] = outArrayResult[i][j]; } } } } } else if (options.remoteObjectId) { console.assert(options.groupId === this._groupId); console.assert( this._objectIdToObject.hasOwnProperty(options.remoteObjectId)); result = this._objectIdToObject[options.remoteObjectId